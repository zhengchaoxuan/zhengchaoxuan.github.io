<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>chapter1--绪论</title>
    <url>/2020/03/25/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%B3%BB%E5%88%97(%E4%B8%80)---%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>&emsp;&emsp;随着疫情的影响，各个大学都开始实施线上授课。我也就算是慢慢结束这慵懒的生活。打算就这每个星期上课的内容做一点点笔记，在每个星期进行梳理，并发布出来，作为一个分享，并让大家给我这个小白看看是不是我的想法有什么错误的地方，以及还需要在那些地方进行改善，哈哈哈，下面就是内容。</p>
<hr>
<p>###1.图像处理的应用实例<br>####人脸识别<br>人脸识别的过程：</p>
<a href="https://i.loli.net/2020/03/25/6yX2meMNDlhEzaG.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img height="200" div align="center" data-src="https://i.loli.net/2020/03/25/6yX2meMNDlhEzaG.png" class="lazyload"></a>

<p>即：输入图像-&gt;计算特征-&gt; 逐一比较(库) -&gt; 得到用户ID</p>
<p>####质量检测<br>1.利用可见光的特性，可以利用一般的摄像头对物体表面进行成像，从而<br>对物体的表面进行分析，实现对产品的质量检测。<br>2.利用X X 射线的穿透能力，可以形成反映物体内部结构的图像，从而对物体<br>的内部结构进行分析，实现对产品的内部进行质量检测。</p>
<p>可见随着科技的进步，为了方便我们的生活和提高我们的生活质量，我们生活中随处可见的地方都应用到了数字图像处理技术。</p>
<hr>
<p>###2.图像的概念<br>####图和像<br>说到图我们往往会和像产生关联，在之前的时间，我一直都没有屈服什么是图，什么是像，下面我们就把这个概念给理清：</p>
<ol>
<li>图是什么? <strong>物体投射或反射光的分布</strong></li>
<li>像是什么？<strong>人的视觉系统对图的接受在大脑中形成的印象或反映</strong></li>
</ol>
<p>这样说来其实图像就是客观和主观的结合。</p>
<p>####模拟图像和数字图像<br><code>模拟图像</code>可以用连续的函数进行表示，其函数表示为</p>
<blockquote>
<p><strong>I=F(x,y)</strong></p>
</blockquote>
<p>其主要特点是：<code>光照强度</code>和<code>光照位置</code>。我们之前使用的胶片相机就是使用这个方法成像的。但是随着计算机的发展，计算机只能识别二进制，图像也向着数字化进行发展，因此产生了数字图像。</p>
<p><code>数字图像</code>由矩阵(数列构成)。其特点是：<code>空间位置</code>和<code>灰度</code>。而且还产生了像素这个概念。而数字图像就是由被称作像素的小块区域组成的二维矩阵。其是离散的，其对于单射灰度图像而已，一个像素的范围是<code>0-255</code>。</p>
<a href="https://i.loli.net/2020/03/25/dcyjfDlYKWVZUz9.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img height="150" div align="center" data-src="https://i.loli.net/2020/03/25/dcyjfDlYKWVZUz9.png" class="lazyload"></a>

<hr>
<p>###3.什么是数字图像处理<br>数字图像处理就是利用计算机系统对数字图像进行各种目的的处理从计算机处理的角度可以由高到低将数字图像分为<code>三个层次</code>。</p>
<blockquote>
<p><strong><code>图像处理</code>——&gt;<code>图像分析</code>——&gt;<code>图像理解</code></strong></p>
<ul>
<li>图像处理：就是对于图像进行像素级别的处理，达到改善视觉效果的作用，主要应用于图像到图像的过程</li>
<li>图像分析： 对图像进行分割以及对于感兴趣部分的特征提取，建立对于图像的描述。</li>
<li>图像理解—我认为是通过图像还原对于现实事物的分析(大神的世界我不懂)</li>
</ul>
</blockquote>
<hr>
<p>###4.例子：指纹识别系统<br>其过程是：</p>
<blockquote>
<ul>
<li>输入原始的灰度图像，进行去噪声(干扰信息)，增强对比度(提高信息量)来实现对于整体化的增强</li>
<li>分割，进行二值化和细化，增强局部特征(其实这步我也懵的)</li>
<li>进行特征提取，使用库进行指纹识别匹配，输出ID</li>
</ul>
</blockquote>
<hr>
<p>###5.使用工具：</p>
<ul>
<li>Visual Studio 2015 及以上(我用VS2019)</li>
<li>OpenCV 3.0 及以上(<a href="https://opencv.org/downloads.html" target="_blank" rel="noopener">官网下载</a>)</li>
<li>Watch imag插件(用于调试时显示和监视图像变量，直接在VS软件添加扩展)</li>
</ul>
<hr>
<p>###6.代码作业和例子<br>1.实现读取图片的功能</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现读取图片的功能</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat <span class="built_in">image</span> = imread(<span class="string">"D:/Vistual studio editor/Code/数字图像处理/1.jpg"</span>,<span class="number">0</span>)<span class="comment">//读入的是灰度图 Gray=R*0.3+G*0.59+B*0.11</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">image</span>.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"无法找到文件！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    namedWindow(<span class="string">"image"</span>,WINDOW_AUTOSIZE);  <span class="comment">//窗口始应图像大小</span></span><br><span class="line">	imshow(<span class="string">"image"</span>, <span class="built_in">image</span>);     <span class="comment">//显示图像</span></span><br><span class="line">    waitkey(<span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>2.实现读取摄像头</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现读取摄像头</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打开摄像头 </span></span><br><span class="line">    VideoCapture objVideo;</span><br><span class="line">    objVideo.<span class="built_in">open</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Mat <span class="built_in">image</span>;</span><br><span class="line">        objVideo&gt;&gt;<span class="built_in">image</span>;</span><br><span class="line"></span><br><span class="line">	    imshow(<span class="string">"image"</span>, <span class="built_in">image</span>);     <span class="comment">//显示图像</span></span><br><span class="line">        waitkey(<span class="number">10</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>3.对像素的灰度值进行灰度获取(放入文本中)和进行灰度的反转</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mat mImg = imread(<span class="string">"D:/图片/壁纸/动漫/1.jpg"</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mImg.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt; <span class="string">"文件无法找到，请先检查路径是否正确"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	Mat grayImage;</span><br><span class="line">	cvtColor(mImg, grayImage, COLOR_BGR2GRAY);     <span class="comment">//将图像转换为灰度图 ---Gray=R*0.3+G*0.59+B*0.11</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获得图像高度和宽度</span></span><br><span class="line">	<span class="keyword">int</span> height_image = grayImage.rows;</span><br><span class="line">	<span class="keyword">int</span> width_image  = grayImage.cols;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置文件流查看全部灰度,以写模式打开文件</span></span><br><span class="line">	ofstream outfile;</span><br><span class="line">	outfile.<span class="built_in">open</span>(<span class="string">"D:/学习课程/大三下学期/数字图像处理/gray.txt"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看各个像素的灰度</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; height_image; ++row)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; width_image; ++col)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">//获取灰度图像row行，col列的像素值，最大255</span></span><br><span class="line">			<span class="keyword">int</span> gray_number = grayImage.at&lt;uchar&gt;(row, col); </span><br><span class="line">			outfile &lt;&lt; gray_number &lt;&lt; <span class="string">' '</span>; <span class="comment">//输入文本 </span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//修改灰度，进行倒反过来</span></span><br><span class="line">			grayImage.at&lt;uchar&gt;(row, col) = <span class="number">255</span> - gray_number;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		outfile &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	outfile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	namedWindow(<span class="string">"change_image"</span>, WINDOW_AUTOSIZE); <span class="comment">//窗口始应图像大小</span></span><br><span class="line">	imshow(<span class="string">"change_image"</span>, grayImage);</span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>第一周的数字图像处理学习就告一段落了，之后我会每一星期都学一篇来巩固一下学习的过程，一起加油！！！</p>
]]></content>
      <categories>
        <category>人工智能</category>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo搭建个人博客</title>
    <url>/2020/03/19/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近闲着没有事情做，就想起来很久之前的想法—自己搭一个简单的个人博客，然后经过选择(其实就是菜)，用<strong>hexo</strong>作为一个个人博客的框架，以及使用Github page 来进行托管个人博客</p>
<p>这就是我的个人博客,可以进去瞧一瞧看一看 : <u><a href="http://zcxblog.top">传送门</a></u><br>我使用的的是<code>butterfly</code>的主题，本来一开始是用<code>next</code>主题的，后来随便逛了一下，就被这个主题吸引住了，而且这个主题安装文档也特别详细，下面我就说下我搭建的过程吧(面向<strong>windows</strong>)</p>
<hr>
<h3 id="hexo的简单搭建和部署到github"><a href="#hexo的简单搭建和部署到github" class="headerlink" title="hexo的简单搭建和部署到github"></a>hexo的简单搭建和部署到github</h3><h4 id="1-什么是Hexo"><a href="#1-什么是Hexo" class="headerlink" title="1.什么是Hexo?"></a>1.什么是Hexo?</h4><p>Hexo 是一个基于<code>Node.js</code>快速、简洁且高效的博客框架。可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页,并生成静态网页托管在Github page上。</p>
<h4 id="2-搭建步骤"><a href="#2-搭建步骤" class="headerlink" title="2.搭建步骤"></a>2.搭建步骤</h4><ol>
<li><p>下载<code>git</code>：</p>
<blockquote>
<p><code>windows</code> ：到<a href="https://gitforwindows.org/" target="_blank" rel="noopener">git官网</a>上下载,下载完后会有一个Git Bash的命令行工具(用来使用git)。安装完可以在命令行窗口输入<code>git --version</code>查看版本</p>
</blockquote>
</li>
<li><p>下载<code>node.js</code>—毕竟是用node.js编写的</p>
<blockquote>
<p><code>windows</code>:<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js官网</a>,选择LTS就可以。安装完可以在命令行窗口输入<code>node -v</code>和<code>npm -v</code>查看版本</p>
</blockquote>
</li>
<li><p>连接github,创建SSH密匙，并且在github添加SSH密匙</p>
<blockquote>
<p>之前写的git基础教程的链接本地仓库和远程仓库的方法</p>
</blockquote>
</li>
<li><p>验证连接</p>
<blockquote>
<p>打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 <code>yes</code></p>
</blockquote>
</li>
<li><p>创建一个github仓库</p>
<blockquote>
<p>仓库名字一定要输入<code>用户名.github.io</code>这样才能识别，不然可能出错，并且勾选 “Initialize this repository with a README”</p>
</blockquote>
</li>
<li><p>安装<code>hexo</code><br>选择一个合适的位置，创建一个文件夹例如blog,鼠标右键然后点开<code>git bash</code>,输入：</p>
<blockquote>
<p>npm install -g hexo-cil</p>
</blockquote>
</li>
<li><p>进行初始化<code>hexo</code>和安装组件:</p>
<blockquote>
<p>hexo init blog<br>cd blog<br>npm install</p>
</blockquote>
</li>
<li><p>然后使用<code>hexo g</code>进行生成静态网页，<code>hexo server</code> 进行预览:</p>
<blockquote>
<p>浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br>如果出现页面加载不出来，可能是端口被占用了。Ctrl+C 关闭服务器，运行 hexo server -p 5000 更改端口号后重试。</p>
</blockquote>
</li>
</ol>
<p>这样Hex的本地博客安装成功就安装完了,下面我介绍一下初始化后生成的文件:</p>
<ul>
<li>source：存放文章</li>
<li>themes：存放主题</li>
<li>scaffolds：生成文章的一些模板</li>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li><font color="red">_config.yml: 博客的配置文件</font></li>
</ul>
<ol start="9">
<li>hexo 部署到Github page<ul>
<li>安装部署命令：<blockquote>
<p>npm install hexo-deployer-git –save</p>
</blockquote>
</li>
<li>修改站点配置文件_config.yml,修改如下:<blockquote>
<p>deploy:<br>  type: git<br>  repository:<code>git@github.com:用户名/用户名.github.io.git</code><br>  branch: master</p>
</blockquote>
</li>
<li>完成后再git bash 允许 git deploy就可以把网站部署到GitHub Pages，你就可以使用<code>http://用户名.github.io</code>来看我们的个人博客了。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-绑定个人域名"><a href="#3-绑定个人域名" class="headerlink" title="3.绑定个人域名"></a>3.绑定个人域名</h3><p>如果感觉github的子域名不好看，那么你就可以去绑定自己的域名替换 GitHub 域名。我使用的是 <a href="https://cn.aliyun.com/" target="_blank" rel="noopener">阿里云</a> 买的域名。<br>你如果购买域名后，就可以再域名控制台中，看到你购买的域名，然后点击解析</p>
<blockquote>
<p>参考文章链接：<a href="https://blog.csdn.net/heimu24/article/details/81159099" target="_blank" rel="noopener">https://blog.csdn.net/heimu24/article/details/81159099</a></p>
</blockquote>
<hr>
<h3 id="hexo配置–根目录下的-config-yml文件"><a href="#hexo配置–根目录下的-config-yml文件" class="headerlink" title="hexo配置–根目录下的_config.yml文件"></a>hexo配置–根目录下的_config.yml文件</h3><blockquote>
<p>参考资料 : <a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">hexo 官方配置文档</a></p>
</blockquote>
<p>其中一些我认为要理解的词语:</p>
<ul>
<li><code>description</code>:主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议包含网站的关键词。</li>
<li><code>permalink</code>:文章的永久链接格式 (有三个参数，默认就好)</li>
<li><code>在permalink</code>到<code>theme</code>之间的配置默认就好，你如果感兴趣也可以对照着官方配置文档进行一定的修改</li>
<li><code>theme</code>：主题可以在hexo官网查找，下载放在theme文件夹下，再修改这个参数就可以改变主题了</li>
</ul>
<h4 id="Front-matter（是文件最上方以-—-分隔的区域，用于指定个别文件的变量）"><a href="#Front-matter（是文件最上方以-—-分隔的区域，用于指定个别文件的变量）" class="headerlink" title="Front-matter（是文件最上方以 — 分隔的区域，用于指定个别文件的变量）"></a>Front-matter（是文件最上方以 — 分隔的区域，用于指定个别文件的变量）</h4><blockquote>
<p>参考资料 ：<a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">hexo 官方front-matter参数文档</a></p>
</blockquote>
<h4 id="布局-layout"><a href="#布局-layout" class="headerlink" title="布局(layout)"></a>布局(layout)</h4><p>hexo有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。</p>
<ol>
<li><p>使用post(默认)</p>
<blockquote>
<p>hexo new [layout] (title)<br>你可以在_posts文件夹上看到你产生的文件</p>
</blockquote>
</li>
<li><p>使用page(另起一页)</p>
<blockquote>
<p>hexo new page tag<br>系统会自动在source文件夹下创建一个tags文件夹，以及tag文件夹中的index.md，这样你访问的tag对应的链接就是<a href="http://xxx.xxx/tag" target="_blank" rel="noopener">http://xxx.xxx/tag</a></p>
</blockquote>
</li>
<li><p>使用draft(草稿,想写文章，又不希望被看到)</p>
<blockquote>
<p>hexo new draft newpage</p>
</blockquote>
<p>系统会自动在source/_draft中新建一个newpage.md文件，如果想要预览一下，那么可以使用命令,然后再本地端口中开启服务预览:</p>
<blockquote>
<p>hexo server –draft</p>
</blockquote>
<p>如果想要发表到post去，输入：</p>
<blockquote>
<p>hexo publish draft newpage</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="4-更换主题"><a href="#4-更换主题" class="headerlink" title="4.更换主题"></a>4.更换主题</h3><p><strong><em>hexo主题网站 :</em></strong> :smile: <u><a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></u> :smile:<br>我使用的是<a href="https://jerryc.me" target="_blank" rel="noopener">butterfly主题</a>,这是他的安装文档：<a href="https://jerryc.me/posts/21cfbf15/#%E5%BF%AB%E9%80%9F%E9%96%8B%E5%A7%8B" target="_blank" rel="noopener">hexo-theme-butterfly安裝文檔</a>，如果你也喜欢这个主题的话，你可以跟着安装文档进行布局。如果你使用别的主题，你也可以直接找该主题的安装文档进行配置。基本上hexo的主题配置都差不多，如果有什么有问题的可以使用百度或者google等浏览器，要相信办法总比困难多:smile:，加油！！！</p>
<hr>
<h3 id="附加一些参考资料"><a href="#附加一些参考资料" class="headerlink" title="附加一些参考资料"></a>附加一些参考资料</h3><blockquote>
<ul>
<li><a href="https://blog.csdn.net/weixin_42429718/article/details/104378207" target="_blank" rel="noopener">hexo+github+coding 搭建个人博客</a></li>
<li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">hexo史上最全搭建教程</a></li>
<li><a href="https://blog.csdn.net/qq_40265501/article/details/80030627" target="_blank" rel="noopener">hexo博客添加搜索功能</a></li>
<li><a href="https://blog.csdn.net/gatieme/article/details/82317704?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">使用 GitHub 分支保存 Hexo 环境和博文</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>人工智能</category>
        <category>创建个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记----廖雪峰的git教程</title>
    <url>/2020/03/19/Git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><a href="https://tse3-mm.cn.bing.net/th/id/OIP.AxXXorDx0eu3bAdop_2B7QHaCh?w=256&h=102&c=7&o=5&dpr=1.25&pid=1.7" data-fancybox="group" data-caption="undefined" class="fancybox"><img div align="left" data-src="https://tse3-mm.cn.bing.net/th/id/OIP.AxXXorDx0eu3bAdop_2B7QHaCh?w=256&h=102&c=7&o=5&dpr=1.25&pid=1.7" class="lazyload"></a>

<h3 id="Git的基本介绍"><a href="#Git的基本介绍" class="headerlink" title="Git的基本介绍"></a>Git的基本介绍</h3><blockquote>
<ol>
<li><strong>Git</strong>是什么?<br>&emsp; Git是目前世界上最先进的分布式版本控制系统（没有之一）</li>
<li>什么是<strong>版本控制系统</strong>？<br>&emsp;  一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统</li>
<li>版本控制系统的分类？<ul>
<li><strong>本地版本控制系统</strong><blockquote>
<p>本地版本控制系统就是在一台机器上，记录版本的不同变化，保证内容不丢失,缺点是没法协同</p>
</blockquote>
</li>
<li><strong>集中式版本控制系統</strong><blockquote>
<p> 集中式版本控制系统都有一个单一的集中管理的服务器（中央服务器），保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新,缺点是需要和依赖中央服务器，且依赖于网络环境进行连接</p>
</blockquote>
</li>
<li><strong>分布式版本控制系統</strong><blockquote>
<p>分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份，每个人的电脑上都是一个完整的版本库。</p>
</blockquote>
</li>
</ul>
</li>
<li>git安装(本人使用的是windows系统)<br>&emsp; git官网上下载 <a href="https://gitforwindows.org/" target="_blank" rel="noopener">Download git</a> ,下载后会有一个Git Bash的命令行工具，用这个工具使用git</li>
</ol>
</blockquote>
<hr>
<h3 id="Git的使用流程"><a href="#Git的使用流程" class="headerlink" title="Git的使用流程"></a>Git的使用流程</h3><p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<blockquote>
<p>git config –global <code>user.name</code> “your name”<br>git config –global <code>user.email</code> “your email”</p>
</blockquote>
<p>ps:每个机器都必须自报家门：你的名字和Email地址<br>&emsp; 注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址</p>
<hr>
<h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><p>1.什么是版本库–<code>reppsitory</code><br>&emsp;&emsp;可以简单理解成一个<code>目录</code>，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”.</p>
<p>2.如何创建？<br><strong>第一步</strong>：选择一个合适的地方，创建一个空目录,打开git bash 输入:</p>
<blockquote>
<p>mkdir learngit<br>cd learngit<br>pwm </p>
</blockquote>
<p><code>pwd</code>命令用于显示当前目录。如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文</p>
<p><strong>第二步</strong>:通过<code>git init</code>命令把这个目录变成Git可以管理的仓库.</p>
<p>这样Git就把仓库建好了(是一个空的仓库(empty Git repository)),当前目录下多了一个<code>.git</code>的目录.这个目录是<strong>Git来跟踪管理版本库的</strong>，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了</p>
<blockquote>
<p>若没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见</p>
</blockquote>
<p>3.添加文件进入版本库–文件必须保存在leangit目录(子目录)</p>
<p>&emsp;&emsp; 所有的版本控制系统，都只能追踪<code>文本文件</code>的改动，比如TXT文件，网页，程序代码等等。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道。</p>
<p><strong>推荐的编辑器</strong>:</p>
<blockquote>
<p>Visual Studio Code : <u><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></u><br>Notepad(默认编码:UTF-8 without BOM) : <u><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">https://notepad-plus-plus.org/</a></u></p>
</blockquote>
<p>ps: 为什么不使用自带的记事本呢，因为Microsoft开发记事本的团队在每个文件(UTF-8编码的文件)开头添加了<code>0xefbbbf</code>的字符,所以会发生一些’有趣’的问题。</p>
<p><strong>文件放到Git仓库</strong><br>1.使用编辑器保存一个txt文件放入目录下(内容自己填写)<br>2.用命令<code>git add</code>告诉Git，把文件添加到仓库：</p>
<blockquote>
<p>git add read.txt</p>
</blockquote>
<p>3.用命令<code>git commit</code>告诉Git，把文件提交到仓库:</p>
<blockquote>
<p>git commit -m ‘add read.txt’</p>
</blockquote>
<p>ps:<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，这样你就能从历史记录里方便地找到改动记录,执行git commit是  可以一次性把暂存区的所有修改提交到分支</p>
<hr>
<h4 id="进行文件处理"><a href="#进行文件处理" class="headerlink" title="进行文件处理"></a>进行文件处理</h4><p>1.使用<code>git status</code>命令掌握仓库的当前状态–包括未暂存，未提交的文件等信息</p>
<blockquote>
<p>git status</p>
</blockquote>
<p>2.使用<code>git diff</code>命令加文件名，可以查看具体修改了什么内容。</p>
<blockquote>
<p><code>git diff</code> —是工作区(work dict)和暂存区(stage)的比较<br><code>git diff --cached</code> —是暂存区(stage)和分支(master)的比较<br><code>git diff HEAD</code>  —查看工作区和版本库里面最新版本的区别</p>
</blockquote>
<hr>
<h4 id="版本查看"><a href="#版本查看" class="headerlink" title="版本查看"></a>版本查看</h4><p>1.使用<code>git log</code>命令显示从最近到最远的提交日志</p>
<blockquote>
<p>git log</p>
</blockquote>
<p>如果嫌输出信息太多,可以加上<code>--pretty=oneline</code>参数：</p>
<blockquote>
<p><code>$</code> git log –pretty=oneline<br>30aa11232b40ec38d8fa86184b3052d091deb759 (HEAD -&gt; master) add 2<br>eb627817424fdc32e2b3d7e89eae0c9fa5c1cb9a add 1</p>
</blockquote>
<p>ps:其中<code>30aa11...</code>是<code>commit id</code>(版本号),<code>add 2</code>是提交的说明(-m)</p>
<p>2.<code>git log</code>和<code>git reflog</code>命令的区别</p>
<blockquote>
<p><strong>git log</strong>可以显示从最近到最远的提交日志，但是不包括已经被删除的 commit 记录和 reset 的操作<br><strong>git reflog</strong>是显示所有的操作记录，包括提交，回退的操作。一般用来找出操作记录中的版本号，进行回退。git reflog常用于恢复本地的错误操作。</p>
</blockquote>
<hr>
<h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>1.使用<code>git reset</code>命令：</p>
<ul>
<li><code>git reset --hard 版本号</code><blockquote>
<p>删除末次提交,并清空所有基与版本号这次commit的修改.可能会造成数据丢失.</p>
</blockquote>
</li>
<li><code>git reset --mixed 版本号</code>-(git reset 的默认设定)<blockquote>
<p>删除某次提交,回到add之前的状态,再次提交先add  在commit</p>
</blockquote>
</li>
<li><code>git reset --soft 版本号</code><blockquote>
<p>只是删除某次提交,再次提交直接commit就可以了</p>
</blockquote>
</li>
</ul>
<p>ps:可使用<code>git reset --hard HEAD^</code>返回上一个版本</p>
<hr>
<h4 id="工作区和版本库"><a href="#工作区和版本库" class="headerlink" title="工作区和版本库"></a>工作区和版本库</h4><h5 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h5><p>它就是你在电脑目录上看到的目录，比如之前创建的文件夹就是工作区。</p>
<h5 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h5><p>工作区有一个隐藏的目录<code>.git</code>，这个就不算是，而是Git的版本库。</p>
<blockquote>
<p>版本库上面有<strong>暂存区(stage)</strong>和分支(自动创建的第一个分支master)以及指向master的一个指针叫HEAD</p>
</blockquote>
<a href="https://www.liaoxuefeng.com/files/attachments/919020037470528/0" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="https://www.liaoxuefeng.com/files/attachments/919020037470528/0" class="lazyload"></a>

<hr>
<h4 id="管理和撤销修改"><a href="#管理和撤销修改" class="headerlink" title="管理和撤销修改"></a>管理和撤销修改</h4><p>1.管理和追踪修改</p>
<blockquote>
<p>每次修改，如果不用git add到暂存区，那就不会加入到commit中,你可以尝试在<code>git add</code>后再修改工作区文件，再<code>git commit</code>比较差别</p>
</blockquote>
<p>2.撤销修改<br>使用<code>git checkout --file</code>可以丢弃工作区的修改:–最新版本使用<code>git restore</code></p>
<blockquote>
<p>1)一种是文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>2)一种是文件已经添加到暂存区后，又作了修改,撤销修改就回到添加到暂存区后的状态。<br>ps:就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
</blockquote>
<p>用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区</p>
<hr>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>在Git中，删除也是一个修改操作，其操作步骤是:</p>
<blockquote>
<ol>
<li>把文件添加(<code>add</code>)，并且提交(<code>commit</code>)</li>
<li>如果需要需要删除文件，可以直接在文件管理器中删除，或者使用命令<code>rm</code>+文件名来删除工作区的文件(使得版本库和工作区不一致),可通过<code>git status</code>查看</li>
<li>进行两种选择：<blockquote>
<ul>
<li>版本库的删除：使用<code>git rm 文件名</code>命令后，进行提交</li>
<li>使用版本库恢复工作区文件: 使用<code>git checkout --文件</code></li>
</ul>
</blockquote>
</li>
</ol>
</blockquote>
<hr>
<h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>前面的学完后可以说再也不用担心文件备份或者丢失的问题了，下面我们就来进行学习使用Github进行Git仓库的托管和创建自己的Git远程仓库</p>
<blockquote>
<p>Github : <u><a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></u></p>
</blockquote>
<h5 id="实现安全传输"><a href="#实现安全传输" class="headerlink" title="实现安全传输"></a>实现安全传输</h5><p>注册完后，使用<code>ssh</code>加密，来实现本地git仓库和github仓库之间的安全传输，步骤如下：</p>
<blockquote>
<p>使用命令: ssh-keygen -t rsa -C “youremail” 一路回车<br>在用户主目录.ssh目录找到<code>id_rsa</code>(私钥)和<code>id_rsa.pub</code>(公钥)俩个文件<br>把<code>id_rsa.pub</code>的内容复制到ssh_key文本框上(名字随意)—ssh_key文本框在<code>github</code>的<code>Account settings</code>的<code>SSH Keys</code>页面添加进去</p>
</blockquote>
<p>ps:github可以添加多个key，从而实现多个电脑向自己的github发推送</p>
<h5 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h5><p>1.在github创建git的仓库(repository)–github有新手的教程有说<br>2.本地仓库关联远程仓库</p>
<blockquote>
<p>git remote add origin <a href="mailto:git@github.com">git@github.com</a>:zhengchaoxuan/one.git<br>其中<strong>zhengchaoxuan</strong>换成你的用户名，<strong>one</strong>缓存你写的项目名字，因为使用了ssh，使用只有必须保证ssh公钥在自己的账户才能连接，<code>origin</code>是远程仓库的名字</p>
</blockquote>
<p>3.关联完后,可以使用<code>git push</code>命令进行把本地分支推送给远程</p>
<blockquote>
<p>git push -u origin master</p>
</blockquote>
<p><code>git push</code>命令就是把当前分支<strong>master</strong>推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了<code>-u</code>参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令使用<code>git push origin master</code>。</p>
<h5 id="使用git-clone-命令克隆一个本地库"><a href="#使用git-clone-命令克隆一个本地库" class="headerlink" title="使用git clone 命令克隆一个本地库"></a>使用git clone 命令克隆一个本地库</h5><blockquote>
<p>git clone <a href="mailto:git@github.com">git@github.com</a>:zhengchaoxuan/one.git</p>
</blockquote>
<p>然后可以进入文件管理器进行查看克隆的文件</p>
<h5 id="ssh警告"><a href="#ssh警告" class="headerlink" title="ssh警告"></a>ssh警告</h5><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告.这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了(可以对照<code>GitHub的RSA Key</code>的指纹信息是否与SSH连接给出的一致)</p>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a><font color="red">分支管理</font></h4><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>在版本回退里，每次提交，Git都把它们串成一条<strong>时间线</strong>.这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<strong>master</strong>分支。<strong>HEAD</strong>严格来说不是指向提交，而是指向<strong>master</strong>，<strong>master</strong>才是指向提交的，所以，HEAD指向的就是当前分支。<br>一开始，master分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：<br><a href="https://upload-images.jianshu.io/upload_images/860220-54f52dc6de61ecb7.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" data-fancybox="group" data-caption="undefined" class="fancybox"><img div align="center" data-src="https://upload-images.jianshu.io/upload_images/860220-54f52dc6de61ecb7.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" class="lazyload"></a></p>
<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br><a href="https://upload-images.jianshu.io/upload_images/860220-243a391b198b9f03.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" data-fancybox="group" data-caption="undefined" class="fancybox"><img div align="center" data-src="https://upload-images.jianshu.io/upload_images/860220-243a391b198b9f03.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" class="lazyload"></a></p>
<p>Git创建一个分支除了增加一个<code>dev</code>指针，改<code>HEAD</code>的指向，工作区的文件都没有任何变化！从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：<br><a href="https://upload-images.jianshu.io/upload_images/860220-394652f23d0642b8.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" data-fancybox="group" data-caption="undefined" class="fancybox"><img div align="center" data-src="https://upload-images.jianshu.io/upload_images/860220-394652f23d0642b8.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" class="lazyload"></a></p>
<p>假如在dev上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：<br><a href="https://upload-images.jianshu.io/upload_images/860220-8eb2733725a66655.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" data-fancybox="group" data-caption="undefined" class="fancybox"><img div align="center" data-src="https://upload-images.jianshu.io/upload_images/860220-8eb2733725a66655.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" class="lazyload"></a></p>
<h5 id="命令实现"><a href="#命令实现" class="headerlink" title="命令实现"></a>命令实现</h5><p>1.创建<code>dev</code>分支，切换到<code>dev</code>分支：</p>
<blockquote>
<p><code>git checkout -b dev</code><br>其表示两条命令:<code>git branch dev</code>创建dev分支，<code>git checkout dev</code>切换到dev分支<br>使用<code>git branch</code>查看当前分支</p>
</blockquote>
<p>可切换到<code>dev</code>分支修改文件，在切换会<code>master</code>分支进行查看，会发现修改的文件内容没变,这就是因为<code>master</code>分支的提交点没有改变.</p>
<p>2.合并某分支到当前分支</p>
<blockquote>
<p><code>git merge dev</code>命令合并到<code>master</code>分支上面(默认使用<code>fast-forward</code>模式–直接把<code>master</code>指向<code>dev</code>的当前提交) </p>
</blockquote>
<p>3.删除branch分支</p>
<blockquote>
<p><code>git brancn -d dev</code><br>当<code>dev</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令<code>git branch -D dev</code></p>
</blockquote>
<p>删除后可以使用<code>git branch</code>命令进行查看分支信息</p>
<p>4.附加<code>switch</code>命令<br>最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p>
<ul>
<li>创建并且切换到<code>dev</code>分支<blockquote>
<p><code>git switch -c dev</code></p>
</blockquote>
</li>
<li>直接切换到已有的分支:<blockquote>
<p><code>git swtch dev</code></p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>出现的情况:</p>
<ol>
<li>当你使用<code>git checkout -b dev</code> 创建并且切换到dev分支上面后，进行修改文件内容，并且，进行<code>add</code>(添加)和<code>commit</code>(提交)后。使用<code>git checkout master</code>返回到<code>master</code>分支后，Git还会自动提示我们当前master分支比远程的master分支要超前1个提交-<code>Your branch is ahead of &#39;origin/master&#39; by 1 commit</code>。</li>
<li>然后在<code>master</code>分支上面，在进行修改文件内容，使用<code>add</code>命令和<code>commit</code>命令进行提交<ul>
<li>基本原理图:<a href="https://upload-images.jianshu.io/upload_images/860220-1ca2b11c1d27d214.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" data-fancybox="group" data-caption="undefined" class="fancybox"><img div align="center" data-src="https://upload-images.jianshu.io/upload_images/860220-1ca2b11c1d27d214.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" class="lazyload"></a></li>
</ul>
</li>
<li>然后使用<code>git merge dev</code>命令进行合并。git会告诉我们无法执行“快速合并”，只能试图把各自的修改合并起来，必须手动解决冲突后再提交。可自行尝试会发生什么</li>
<li>使用<code>git status</code>告诉我们冲突的文件是什么。查看文件内容后会发现，Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容。我们可以进行修改(选择一个分支的内容),然后使用<code>add</code>和<code>commit</code>进行提交<ul>
<li>基本原理图:<a href="https://upload-images.jianshu.io/upload_images/860220-757f942183bb91a4.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" data-fancybox="group" data-caption="undefined" class="fancybox"><img div align="center" data-src="https://upload-images.jianshu.io/upload_images/860220-757f942183bb91a4.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" class="lazyload"></a>

</li>
</ul>
</li>
</ol>
<p>5.带参数的<code>git log</code>也可以看到分支的合并情况</p>
<blockquote>
<p><code>git log --gragh --pretty=oneline --abbrev-commit</code></p>
</blockquote>
<p>6.最后删除分支</p>
<blockquote>
<p><code>git brancn -d dev</code></p>
</blockquote>
<hr>
<h4 id="合并模式"><a href="#合并模式" class="headerlink" title="合并模式"></a>合并模式</h4><p>1.合并分支默认使用<code>--ff</code>模式(faster forward),其实git merge命令有三种模式，其效果简述如下：</p>
<blockquote>
<p><code>git merge dev</code> ：如果删除分支，则会丢失merge分支信息<br><code>git merge --squash dev</code> ：不提交、不移动HEA.需要一条额外的commit命令。其效果相当于将another分支上的多个commit合并成一个，放在当前分支上，原来的commit历史则没有拿过来。<br><code>git merge --no-ff dev</code> ：表示禁用–ff模式,会创建一个merge的commit信息，然后合并的和master分支</p>
</blockquote>
<p>ps:附带我之前看到简单文章 : <a href="https://www.jianshu.com/p/418323ed2b03" target="_blank" rel="noopener">git merge和git merge –no-ff的区别</a></p>
<hr>
<h4 id="隐藏’工作现场’"><a href="#隐藏’工作现场’" class="headerlink" title="隐藏’工作现场’"></a>隐藏’工作现场’</h4><p>当你在进行一个分支处理时，你突然收到一个任务要创建另外一个分支进行处理。但是你在当前<code>dev</code>分支进行的工作还没完成，你使用<code>git status</code>会提示你需要进行提交，但是不想提交，这个时候就需要进行把当前的”工作现场”进行隐藏，等以后恢复现场在继续现在的工作</p>
<blockquote>
<p><code>git stash</code></p>
</blockquote>
<p>使用后你可以通过<code>git status</code>命令进行查看，发现工作区非常的干净(除非有没有被git管理的文件)，你就可以安心去别的分支进行别的处理了</p>
<hr>
<h4 id="恢复’工作现处’"><a href="#恢复’工作现处’" class="headerlink" title="恢复’工作现处’"></a>恢复’工作现处’</h4><p>当工作完成后,切换回之前隐藏工作现场的<code>dev</code>分支，然后使用命令<code>git stash list</code>来查看工作现场，现在有俩种方式进行恢复：</p>
<ol>
<li>使用命令<code>git stash apply</code>恢复，但是<code>stash</code>内容并不删除，你需要用<code>git stash drop</code>来删除,可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后用命令<code>git stash apply stash@{number}</code>恢复指定的stash,其中number是序列号</li>
<li>用<code>git stash pop</code>，恢复的同时把stash内容也删了</li>
</ol>
<hr>
<h4 id="多人协同"><a href="#多人协同" class="headerlink" title="多人协同"></a><font color="red">多人协同</font></h4><p>1.本地库和远程库关联后，查看远程库信息:</p>
<blockquote>
<p>git remote  :简单信息<br>git remote  -v :更具体一点的信息</p>
</blockquote>
<p>2.抓取分支<br>多人协作时，大家都会往master和dev分支上推送各自的修改。当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支(默认分支)。要在<code>dev</code>分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：</p>
<blockquote>
<p><code>git checkout -b dev origin/dev</code></p>
</blockquote>
<p>这样就可以使用<code>git push</code>发推送到远程了。</p>
<p>3.如果你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，就会出现推送失败的情况(你的小伙伴的最新提交和你试图推送的提交有冲突)。这时你就可以先<code>git pull</code>把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送,不过要进行指定连接命令<code>git branch --set-upstream dev origin/dev</code>,这样在<code>pull</code>在本地手动解决冲突，在<code>git push</code>上去就好了</p>
<hr>
<h4 id="添加标签（更好的管理文件）"><a href="#添加标签（更好的管理文件）" class="headerlink" title="添加标签（更好的管理文件）"></a>添加标签（更好的管理文件）</h4><p>1.因为<code>commit id</code>有点长，添加标签更好的管理文件,使用方式：</p>
<blockquote>
<p><code>git tag v0.1</code>  :这样就给当前分支打上标签</p>
</blockquote>
<p>2.使用<code>git tag</code>查看所有标签,也可以使用<code>git show &lt;tagname&gt;</code>查看标签信息。<br>3.如果想要给之前的commit打上标签，可以使用查看<code>commit id</code>,然后使用:</p>
<blockquote>
<p><code>git tag v0.2 commitID</code></p>
</blockquote>
<p>4.删除标签</p>
<blockquote>
<p><code>git tag -d &lt;tagname&gt;</code></p>
</blockquote>
<p>5.推送一个本地标签</p>
<blockquote>
<p><code>git push origin &lt;tagname&gt;</code></p>
</blockquote>
<p>6.一次性推送全部尚未推送到远程的本地标签</p>
<blockquote>
<p><code>git push origin --tags</code></p>
</blockquote>
<p>7.删除远程标签</p>
<blockquote>
<p><code>git tag -d &lt;tagname&gt;</code>  先删除本地标签<br><code>git push origin :refs/tags/v0.1</code>  从远程删除</p>
</blockquote>
<hr>
<h4 id="一些之前看过的网站"><a href="#一些之前看过的网站" class="headerlink" title="一些之前看过的网站"></a>一些之前看过的网站</h4><ol>
<li><strong>网站</strong><blockquote>
<ul>
<li><u><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰git教程</a></u></li>
<li><u><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git - Book</a></u></li>
<li><u><a href="https://www.cnblogs.com/linxiu-0925/p/10138902.html" target="_blank" rel="noopener">sourceTree安装和使用(windows)</a></u></li>
<li><u><a href="https://blog.csdn.net/y_bccl27/article/details/87980986" target="_blank" rel="noopener">GitHub上如何创建文件夹</a></u></li>
<li><u><a href="https://blog.csdn.net/baidu_33387365/article/details/80884585?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">git clone与git pull区别</a></u></li>
<li><u><a href="https://www.cnblogs.com/haoshine/p/5887890.html" target="_blank" rel="noopener">Git .gitignore文件的使用</a></u></li>
</ul>
</blockquote>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>人工智能</category>
        <category>创建个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Markdown基本语法</title>
    <url>/2020/03/17/Markdomn%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="认识Markdown语言"><a href="#认识Markdown语言" class="headerlink" title="认识Markdown语言 "></a>认识Markdown语言 <a href="https://tse1-mm.cn.bing.net/th/id/OIP.bo-9Gk0DsJpyHsKnvpZa_gHaEj?w=295&h=177&c=7&o=5&dpr=1.25&pid=1.7" data-fancybox="group" data-caption="undefined" class="fancybox"><img div align="left" data-src="https://tse1-mm.cn.bing.net/th/id/OIP.bo-9Gk0DsJpyHsKnvpZa_gHaEj?w=295&h=177&c=7&o=5&dpr=1.25&pid=1.7" class="lazyload"></a></h2><p>Markdown是一种轻量级的「标记语言」，它允许人们使用易读易写的纯文本格式编写文档</p>
<p>Markdown语言编写的文档可以导出为HTML，world,图像，PDF，Epub等多种格式的文档<br>Markdown常用的标记符号也不超过十个    </p>
<h2 id="Markdown文档资料"><a href="#Markdown文档资料" class="headerlink" title="Markdown文档资料"></a>Markdown文档资料</h2><p>Markdown语言能被使用来撰写电子书，如Gitbook。</p>
<ol>
<li><u><a href="https://daringfireball.net/projects/markdown/syntax" target="_blank" rel="noopener">创始人 John Gruber 的 Markdown 语法说明</a></u></li>
<li><u><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">Markdown教程|菜鸟教程</a></u></li>
</ol>
<hr>
<h2 id="Markdown语言编辑器"><a href="#Markdown语言编辑器" class="headerlink" title="Markdown语言编辑器"></a>Markdown语言编辑器</h2><ol>
<li>Typora编辑器—Typora官网: <u><a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a></u></li>
<li>Visual Studio Code(需要添加插件)—Visual Studio Code官网:<u><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></u></li>
</ol>
<hr>
<h2 id="Markdown简单语法规则"><a href="#Markdown简单语法规则" class="headerlink" title="Markdown简单语法规则"></a>Markdown简单语法规则</h2><h3 id="标题-两种表示方式"><a href="#标题-两种表示方式" class="headerlink" title="标题(两种表示方式)"></a>标题(两种表示方式)</h3><h4 id="1-使用-号进行标记"><a href="#1-使用-号进行标记" class="headerlink" title="1. 使用 # 号进行标记"></a>1. 使用 # 号进行标记</h4><p>使用 # 号可表示<code>1-6</code> 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号….</p>
<blockquote>
<p># 一级标题<br>## 二级标题<br>### 三级标题<br>….</p>
</blockquote>
<p>效果如下:</p>
<blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>….</p>
</blockquote>
<h4 id="2-使用-和-作为一级和二级标题"><a href="#2-使用-和-作为一级和二级标题" class="headerlink" title="2. 使用 = 和 - 作为一级和二级标题"></a>2. 使用 = 和 - 作为一级和二级标题</h4><blockquote>
<p>一级标题<br>=========<br>二级标题<br>----------------<br>….</p>
</blockquote>
<p>效果如下:</p>
<blockquote>
<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote>
<hr>
<h3 id="段落格式"><a href="#段落格式" class="headerlink" title="段落格式"></a>段落格式</h3><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用<code>两个以上空格加上回车</code>或者使用<code>一个空行</code></p>
<h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p>基础字体如下:</p>
<blockquote>
<p>*斜体文本*<br>_斜体文本_<br>**粗体文本**<br>__粗体文本__<br><em>\</em>*粗斜体文本***<br>___粗斜体文本___</p>
</blockquote>
<p>效果如下:</p>
<blockquote>
<p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong></p>
</blockquote>
<h4 id="段首空格"><a href="#段首空格" class="headerlink" title="段首空格"></a>段首空格</h4><p>使用<code>&amp;ensp;</code> 表示全角空格的一半(中文)<br>使用<code>&amp;emsp;</code> 表示全角空格(中文)<br>使用<code>&amp;nbsp;</code> 半角空格(英文)   </p>
<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>使用三个以上的<code>*</code>或者是<code>-</code>建立分隔线(行内不能有其他的东西,但是可以在它们中间加空格)</p>
<h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p>在文字两端加两个波浪线~~，如下:</p>
<blockquote>
<p>~~删除线~~<br><del>删除线</del></p>
</blockquote>
<h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4><p>在文字前端加上<code>\&lt;u&gt;</code>在文字后端加上<code>\&lt;/u&gt;</code>(HTML语法),如下：</p>
<blockquote>
<p>&lt;u&gt;文字&lt;/u&gt;<br><u>文字</u></p>
</blockquote>
<h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><p>脚注的格式(效果自己尝试): </p>
<blockquote>
<p>[^脚注]<br>[^脚注]: 学习Markdown语法 </p>
</blockquote>
<hr>
<h3 id="列表-两种类型"><a href="#列表-两种类型" class="headerlink" title="列表(两种类型)"></a>列表(两种类型)</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>无序列表使用<code>+</code>,<code>-</code>,<code>*</code>作为列表标记:</p>
<blockquote>
<p>+ 第一个序列<br>- 第二个序列<br>* 第三个序列</p>
</blockquote>
<p>效果如下:</p>
<blockquote>
<ul>
<li>第一个序列</li>
</ul>
<ul>
<li>第二个序列</li>
</ul>
<ul>
<li>第三个序列</li>
</ul>
</blockquote>
<h4 id="有序序列"><a href="#有序序列" class="headerlink" title="有序序列"></a>有序序列</h4><p>有序序列使用数字加上<code>.</code>空格作为列表标记:</p>
<blockquote>
<ol>
<li>第一个序列</li>
<li>第二个序列</li>
<li>第三个序列  </li>
</ol>
</blockquote>
<h4 id="综合–嵌套序列-在子列表添加4个空格"><a href="#综合–嵌套序列-在子列表添加4个空格" class="headerlink" title="综合–嵌套序列(在子列表添加4个空格):"></a>综合–嵌套序列(在子列表添加4个空格):</h4><blockquote>
<ol>
<li>第一个序列:<br>* 第一项<br>* 第二项</li>
<li>第二个序列:<br>* 第一项<br>* 第二项</li>
</ol>
</blockquote>
<p>效果如下:</p>
<blockquote>
<ol>
<li>第一个序列:<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
</li>
<li>第二个序列:<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
</li>
</ol>
</blockquote>
<hr>
<h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p>在段落的开头使用<code>&gt;</code>符号，再<em>空格</em> ：</p>
<p>&gt; 段落区块</p>
<p>效果如下:</p>
<blockquote>
<p>段落区块</p>
</blockquote>
<h4 id="区块嵌套"><a href="#区块嵌套" class="headerlink" title="区块嵌套"></a>区块嵌套</h4><p>表示形式：<br>&gt; 最外层<br>&gt;&gt; 第一层嵌套<br>&gt;&gt;&gt; 第二层嵌套</p>
<p>效果如下：</p>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<p>PS:区块可以配合序列…的一起使用，进行更好的排版</p>
<hr>
<h3 id="代码显示"><a href="#代码显示" class="headerlink" title="代码显示"></a>代码显示</h3><p>使用反引号 <strong>(`)</strong> 包含，效果如下: <code>opencv</code></p>
<h4 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块:"></a>代码区块:</h4><p>使用 <strong><em>```</em></strong> 包含一段代码，并指定一种语言:</p>
<blockquote>
<p>```python<br>if __name__ == “__main__“:<br>&emsp;&emsp;main()<br>```</p>
</blockquote>
<p>效果如下:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="链接-两种方式"><a href="#链接-两种方式" class="headerlink" title="链接(两种方式)"></a>链接(两种方式)</h3><p>直接使用&lt;链接地址&gt;,效果如下:<br><a href="http://zcxblog.top">http://zcxblog.top</a>   </p>
<p>使用[链接名字] (链接地址),效果如下:<br><a href="http://zcxblog.top">ZhengCXuan的个人博客</a></p>
<hr>
<h3 id="Markdown添加图片"><a href="#Markdown添加图片" class="headerlink" title="Markdown添加图片"></a>Markdown添加图片</h3><p>插入图片最基础的格式:</p>
<blockquote>
<p>![Alt text](图片链接 “title”)<br>Alt text：图片的标签，用来描述图片的关键词(可不写)。本意是当图片因为某种原因不能被显示时而出现的替代文字，后来被用于SEO<br>“title”：鼠标悬置于图片上会出现的标题文字(可不写)</p>
</blockquote>
<p>插入本地图片的方法:</p>
<blockquote>
<ol>
<li>在md文件的同及目录新建image文件夹,放入图片</li>
<li>在代码中加入![avatar] (./image/你的图片名字.png)</li>
</ol>
</blockquote>
<p>插入图片并且设置图片大小和位置：</p>
<blockquote>
<p>&lt;img src=”<code>http:...</code>“ width = “<code>100</code>“ height = “<code>100</code>“ div align=<code>right</code>/&gt;<br> <strong>PS</strong>:可以在后边输入百分比为多少，如 width = 10% height = 10%<br> &emsp;&ensp; <em>align</em>:<code>left</code>,<code>right</code>,<code>center</code> 三种选项</p>
</blockquote>
<hr>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>基础格式代码:</p>
<blockquote>
<table>
<thead>
<tr>
<th>第一行表头</th>
<th>第二行表头</th>
<th>第二行表头</th>
</tr>
</thead>
<tbody><tr>
<td>短文本</td>
<td>中等文本</td>
<td>长一点的文本示范</td>
</tr>
<tr>
<td>长一点的文本示范</td>
<td>短本</td>
<td>中等文本</td>
</tr>
</tbody></table>
</blockquote>
<p>效果如下:</p>
<blockquote>
<table>
<thead>
<tr>
<th>第一行表头</th>
<th>第二行表头</th>
<th>第二行表头</th>
</tr>
</thead>
<tbody><tr>
<td>短文本</td>
<td>中等文本</td>
<td>长一点的文本示范</td>
</tr>
<tr>
<td>长一点的文本示范</td>
<td>短本</td>
<td>中等文本</td>
</tr>
</tbody></table>
<blockquote>
<p>ps : 表格默认为表头居中，下面表格居左侧<br>&emsp;&ensp; 可设置<code>:--</code>为居左，<code>:--:</code>为居中，<code>--:</code>为居右</p>
</blockquote>
</blockquote>
<hr>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote>
<p>&emsp;作为一个新手,学习Markdown语法目的是用来进行hexo框架下个人博客的编辑，感觉这样下来，这些基本的语法应付日常的博客编写已经没有什么问题了，如果还要什么问题的话根据问题自行百度,google就行了，这也是我第一次用Markdown写东西，写的东西会有点差吧。一起加油</p>
</blockquote>
]]></content>
      <categories>
        <category>人工智能</category>
        <category>创建个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
